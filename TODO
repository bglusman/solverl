By priority:

 Documentation.

 Provide more ways to handle solution handler exceptions.

 Parse dzn to be able to do more accurate checks.

 Add example of Erlang project with rebar-mix.

 Configure logging as a solve/solve_sync param

 Make a sample web app with Phoenix (Sudoku?)
 
 Parameter for limiting number of solutions (?)
=========================================================================================================
+ Add inactivity timeouts (possibly separately for compilation and solving)
+ Branch-and-bound: implementation and example.
+ LNS: implementation and example.
+ Pass GenServer options to MinizincPort.
+ Store mzn-stats elements with the same key as an array (bug!)
+ Provide call for status of the solver (compiles/runs, time since last output, # of solutions found).
+ Analyze model (and type-check data?) with '--model-interface-only'
+ More events/timestamps (compile time, time since last solution etc.)
+ Replace Port by erlexec or its Elixir wrapper.
+ Option to skip time_limit
+ Add functions to access solver results
+ Examples: Add graph coloring.
+ Make sure the solver events get flushed even if receiver crashes!
+ Add model and data files to the solver state.
+ Erlang interface.
+ More test cases (data conversions).
+ Add :skip to solve_sync
+ Make results of solve_sync into a map of :solutions, :summary, :minizinc_error
+ Rethink :stop behaviour; better residual msg cleanup after :stop.
+ Merge solution-related fields into a record
+ Parse key-values into {atom(), native_type()}
+ Handle minizinc start errors (such as improper model / missed data)
+ Synchronous solving
+ Review for private functions.
